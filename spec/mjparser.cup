package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.*;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

parser code {:
    Logger logger = LogManager.getLogger(MJParser.class);

    boolean errorDetected = false;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol curr_token) {
        report_error("Syntax error while parsing", curr_token);
    }

    public void unrecovered_syntax_error(Symbol curr_token) throws java.lang.Exception {
        report_fatal_error("Could not recover from syntax error", curr_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            msg.append(" on line ").append(symbol.left);
            msg.append(" and column ").append(symbol.right);
            msg.append(" while parsing ").append(LexerUtils.GetLexicalIdentifier(symbol.toString()));
            msg.append(" with value ").append(symbol.value);
        }
        logger.error(msg.toString());

        errorDetected = true;
    }
:}

scan with {:
    Symbol symbol = this.getScanner().next_token();
    if (symbol != null && symbol.value != null) {
        logger.info("Line " + symbol.left + ": " + "Parsed symbol: " + symbol.value + " - " + LexerUtils.GetLexicalIdentifier(symbol.toString()));
    }
    return symbol;
:}

//nonterminal Program, ProgramName;

terminal String IDENTIFIER;
terminal Integer CONST_NUMBER;
terminal Character CONST_CHARACTER;

/*
    Keywords:
        program, break, class, enum, else, const, if, do, while, new, print, read,
        return, void, extends, continue, this, foreach
*/
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ;
terminal EXTENDS, CONTINUE, FOR_EACH;
terminal THEN, STATIC;

/* TODO (acko): enum, do, this, return, void, this, THEN??? STATIC??? */

terminal RETURN;

/* Constants */
terminal CONST_BOOLEAN;

/* Operators */
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal INCREMENT, DECREMENT;
terminal AND, OR;
terminal LAMBDA;
terminal LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal DOT, COMMA, SEMI_COLON;
terminal ASSIGNMENT;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_OR_EQUAL_THAN, LESS_OR_EQUAL_THAN;

//nonterminal GlobalDeclarationList, GlobalDeclarataion;
//nonterminal ConstantDeclarationList, VariableDeclarationList, ClassDeclarationList, MethodDeclarationList;
//nonterminal AssignmentOperator, RelationOperator, AdditionOperator, MultiplicationOperator;

//nonterminal Type, MethodDeclaration, MethodTypeName, FormalParameters;

/* ========================================================================== */


/* Program */
nonterminal Program, GlobalDeclarationList, GlobalDeclaration, MethodDeclarationList, MethodDeclaration;

/* Common */
nonterminal Type, Sign, MaybeArray;

/* Constants */
nonterminal ConstDecl, ConstDeclarationList, ConstAssignment, Constant;

/* Variables */
nonterminal VarDecl, VariableDeclarationList, VariableDeclaration;

/* Operators */
nonterminal AssignmentOperator, AdditionOperator, MultiplicationOperator, RelationalOperator;

/* TODO (acko): Rewrite this */
nonterminal Statement, Expr, Factor, Term, Designator, ConstFactor;

/*
    Program = "program" ident {ConstDecl | VarDecl | ClassDecl} "{" {MethodDecl} "}".

    Introduce a new nonterminal GlobalDeclaration = ConstDecl | VarDecl | ClassDecl
*/

Program ::=
    (Program) PROGRAM IDENTIFIER SEMI_COLON GlobalDeclarationList LEFT_BRACE MethodDeclarationList RIGHT_BRACE;

GlobalDeclarationList ::=
    (GlobalDeclarationListMulti) GlobalDeclarationList GlobalDeclaration
    | (GlobalDeclarationListEpsilon) /* epsilon */;

GlobalDeclaration ::=
    (GlobalDeclarationConstDecl) ConstDecl
    | (GlobalDeclarationVarDecl) VarDecl;

/* ConstDecl = "const" Type ident"="(numConst | charConst | boolConst) {, ident "=" (numConst | charConst | boolConst)} ";" */

ConstDecl ::=
    (ConstDecl) CONST Type ConstDeclarationList SEMI_COLON;

ConstDeclarationList ::=
    (ConstDeclarationListMulti) ConstDeclarationList COMMA ConstAssignment
    | (ConstDeclarationListSingle) ConstAssignment;

ConstAssignment ::=
    (ConstAssignment) IDENTIFIER AssignmentOperator Constant;

Constant ::=
    (ConstantNumber) Sign CONST_NUMBER
    | (ConstantCharacter) CONST_CHARACTER
    | (ConstantBoolean) CONST_BOOLEAN;

/* VarDecl = Type ident ["[" "]"] {"," ident ["[" "]"]} ";" */

VarDecl ::=
    Type VariableDeclarationList SEMI_COLON;

VariableDeclarationList ::=
    (VariableDeclarationListMulti) VariableDeclarationList COMMA VariableDeclaration
    | (VariableDeclarationSingle) VariableDeclaration;

VariableDeclaration ::=
    (VariableDeclaration) IDENTIFIER MaybeArray;

MethodDeclarationList ::=
    (MethodDeclarationListMulti) MethodDeclarationList MethodDeclaration
    | (MethodDeclarationListEpsilon) /* epsilon */;

MethodDeclaration ::= Statement;

/*
    ClassDecl = "class" ident ["extends" Type] "{" {VarDecl} ["{" {ConstructorDecl} {MethodDecl} "}"] "}"
    ConstructorDecl = ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}. * za C nivo'

    TODO (acko): Add ClassDecl/ConstructorDecl
*/

/* Factor := numConst | charConst | "(" Expr ")" | boolConst | "new" Type "[" Expr "]"| Designator */

/*
    Factor = Designator ["(" [ActPars] ")"]
    | numConst
    | charConst
    | boolConst
    | "new" Type ( "[" Expr "]" | "" ([ActPars] ")" )
    | "(" Expr ")".
*/

/* TODO (acko): Rewrite this */
Statement ::=
    (StatementPrint) PRINT LEFT_PARENTHESES Expr RIGHT_PARENTHESES SEMI_COLON;

Expr ::=
    (ExprMulti) Expr AdditionOperator Term
    | (ExprSingle) Sign Term;

Term ::=
    (TermMulti) Term MultiplicationOperator Factor
    | (TermSingle) Factor;

Factor ::=
    (FactorConstant) ConstFactor
    | (FactorDesignator) Designator
    | (FactorExpr) LEFT_PARENTHESES Expr RIGHT_PARENTHESES;

ConstFactor ::=
    CONST_NUMBER
    | CONST_CHARACTER
    | CONST_BOOLEAN;

Designator ::=
    (DesignatorIdentifier) IDENTIFIER;

/* Assignop = "=" */

AssignmentOperator ::=
    (AssignmentOperator) ASSIGNMENT;

/* AddOp = "+" | "‐" */

AdditionOperator ::=
    (AdditionOperatorAddition) ADDITION
    | (AdditionOperatorSubtraction) SUBTRACTION;

/* MulOp = "*" | "/" | "%" */

MultiplicationOperator ::=
    (MultiplicationOperatorMultiplication) MULTIPLICATION
    | (MultiplicationOperatorDivision) DIVISION
    | (MultiplicationOperatorModulo) MODULO;

/* RelOp = "==" | "!=" | ">" | ">=" | "<" | "<=" */

RelationalOperator ::=
    (RelationalOperatorEquals) EQUALS
    | (RelationalOperatorNotEquals) NOT_EQUALS
    | (RelationalOperatorGreaterThan) GREATER_THAN
    | (RelationalOperatorGreaterOrEqualThan) GREATER_OR_EQUAL_THAN
    | (RelationalOperatorLessThan) LESS_THAN
    | (RelationalOperatorLessOrEqualThan) LESS_OR_EQUAL_THAN;

/* Type = ident */

Type ::=
    (Type) IDENTIFIER;

/* Sign = [ "+" | "-" ] */
Sign ::=
    (SignPositive) ADDITION
    | (SignNegative) SUBTRACTION
    | (SignEpsilon) /* epsilon */;

/* MaybeArray = [ "[" "]" ] */

MaybeArray ::=
    (MaybeArrayIsArray) LEFT_BRACKET RIGHT_BRACKET
    | (MaybeArrayEpsilon) /* epsilon */;

