package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.*;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

parser code {:
    Logger logger = LogManager.getLogger(MJParser.class);

    boolean errorDetected = false;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol curr_token) {
        report_error("Syntax error while parsing", curr_token);
    }

    public void unrecovered_syntax_error(Symbol curr_token) throws java.lang.Exception {
        report_fatal_error("Could not recover from syntax error", curr_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            msg.append(" on line ").append(symbol.left);
            msg.append(" and column ").append(symbol.right);
            msg.append(" while parsing ").append(LexerUtils.GetLexicalIdentifier(symbol.toString()));
            msg.append(" with value ").append(symbol.value);
        }
        logger.error(msg.toString());

        errorDetected = true;
    }
:}

scan with {:
    Symbol symbol = this.getScanner().next_token();
    if (symbol != null && symbol.value != null) {
        logger.info("Line " + symbol.left + ": " + "Parsed symbol: " + symbol.value + " - " + LexerUtils.GetLexicalIdentifier(symbol.toString()));
    }
    return symbol;
:}

nonterminal Program, ProgramName;

terminal String IDENTIFIER;
terminal Integer CONST_NUMBER;
terminal Character CONST_CHARACTER;

/*
    Keywords:
        program, break, class, enum, else, const, if, do, while, new, print, read,
        return, void, extends, continue, this, foreach
*/
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ;
terminal EXTENDS, CONTINUE, FOR_EACH;
terminal THEN, STATIC;

/* TODO (acko): enum, do, this, return, void, this, THEN??? STATIC??? */

terminal RETURN;

/* Constants */
terminal CONST_BOOLEAN;

/* Operators */
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal INCREMENT, DECREMENT;
terminal AND, OR;
terminal LAMBDA;
terminal LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal DOT, COMMA, SEMI_COLON;
terminal ASSIGNMENT;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_OR_EQUAL_THAN, LESS_OR_EQUAL_THAN;

nonterminal GlobalDeclarationList, GlobalDeclarataion;
nonterminal ConstantDeclarationList, VariableDeclarationList, ClassDeclarationList, MethodDeclarationList;
nonterminal AssignmentOperator, RelationOperator, AdditionOperator, MultiplicationOperator;

nonterminal Type, MethodDeclaration, MethodTypeName, FormalParameters;

nonterminal ConstantDeclaration, VariableTypeName, Constant, Factor;

nonterminal Term;

nonterminal MaybeArray, VariableDeclaration, VariableDeclarationListWithSeparator;

nonterminal MaybeNegative;

nonterminal  MatchedStatement, UnmatchedStatement;
nonterminal Condition, CondTerm, CondFact, Expr, MaybeExpr;

nonterminal MaybePrintNumConst, Designator, StatementList;

nonterminal DesignatorStatement;

nonterminal ActPars, MaybeActPars, MaybeActParsInvocation;

nonterminal MethodField, MethodFieldList;

//nonterminal MaybeSubscript;


nonterminal FormPars, FormParsCSV, FormalParameter;

nonterminal DesignatorList;

/* Better name please TODO (acko): */
nonterminal DesigSuffix, DesigExtra, SingleDesignator;

nonterminal Acko;

nonterminal MaybeDesignator;

nonterminal Statement;
precedence left ELSE;

/*  "program" ident { ConstDecl | VarDecl | ClassDecl } "{" {MethodDecl} "}" */

Program ::=
    (Program) PROGRAM ProgramName GlobalDeclarationList
        LEFT_BRACE MethodDeclarationList RIGHT_BRACE;

ProgramName ::=
    (ProgramName) IDENTIFIER:programName;

GlobalDeclarationList ::=
    (GlobalDeclarations) GlobalDeclarationList GlobalDeclarataion
    | (GlobalDeclarationEpsilon) /* epsilon */;

GlobalDeclarataion ::=
    (GlobalDeclarationConstantDeclarationList) CONST Type ConstantDeclarationList SEMI_COLON
    | (GlobalDeclarationVariableDeclarationList) Type VariableDeclarationList SEMI_COLON
    | (GlobalDeclarationClassDeclarationList) ClassDeclarationList;

ConstantDeclarationList ::=
    (ConstantDeclarations) ConstantDeclarationList COMMA ConstantDeclaration
    | (ConstantDeclarationListSingle) ConstantDeclaration;

/* VarDecl = Type ident ["[" "]"] {"," ident ["[" "]"]} ";" */

VariableDeclarationList ::=
    (VariableDeclarations) VariableDeclarationListWithSeparator VariableDeclaration
     | (VariableDeclerationListSingle) VariableDeclaration;

VariableDeclarationListWithSeparator ::=
    (VariableDeclarationListWithSeparatorNoError) VariableDeclarationList COMMA
    | (VariableDeclarationListWithSeparatorError) error COMMA:l {: parser.report_error("Syntax error while declaring variable on line " + lleft, null); :};

VariableDeclaration ::=
    (VariableDeclaration) IDENTIFIER:variableName MaybeArray;

MaybeArray ::=
    (MaybeArrayIsArray) LEFT_BRACKET RIGHT_BRACKET
    | (MaybeArrayEpsilon) /* epsilon */;

/* TODO(acko): Fix me please. */

ClassDeclarationList ::=
    (ClassDeclarationList) CLASS /* epsilon */;

MethodDeclarationList ::=
    (MethodDeclarations) MethodDeclarationList MethodDeclaration
    | (MethodDeclarationEpsilon) /* epsilon */;

MethodDeclaration ::=
    (MethodDeclaration) MethodTypeName FormalParameters
        MethodFieldList LEFT_BRACE StatementList RIGHT_BRACE;

/* TODO (acko): Think of a better name for method fields... */

MethodFieldList ::=
    (MethodFieldListMulti) MethodField MethodFieldList
    | (MethodFieldListEpsilon) /* Epsilon */;

MethodField ::=
    (MethodFieldComma) Type VariableDeclaration SEMI_COLON;

/* Type = ident */
Type ::=
    (Type) IDENTIFIER:typeName;

MethodTypeName ::=
    (MethodTypeName) Type:returnType IDENTIFIER:methodName;

/* FormPars = Type ident ["[" "]"] {"," Type ident ["[" "]"]} */

FormalParameters ::=
    (FormalParametersEmptyList) LEFT_PARENTHESES RIGHT_PARENTHESES
    | (FormalParametersList) LEFT_PARENTHESES FormPars RIGHT_PARENTHESES;

FormPars ::=
    (FormParsMulti) FormParsCSV FormalParameter
    | (FormParsSingle) FormalParameter;

FormParsCSV ::=
    (FormParsCSV) FormPars COMMA;

FormalParameter ::=
    (FormalParameter) Type IDENTIFIER MaybeArray;

/* ConstDecl = "const" Type ident "=" (numConst | charConst | boolConst) ";" */

ConstantDeclaration ::=
    (ConstantDeclaration) IDENTIFIER:variable ASSIGNMENT Constant;

Constant ::=
    (ConstantNumber) CONST_NUMBER
    | (ConstantCharacter) CONST_CHARACTER
    | (ConstantBoolean) CONST_BOOLEAN;

VariableTypeName ::=
    (VariableTypeName) Type:variableType IDENTIFIER:variable;

/* MethodDecl = (Type | "void") ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}" */
/* FormPars = Type ident ["[" "]"] {"," Type ident ["[" "]"]} */

MaybeNegative ::=
    (MaybeNegativeIsNegative) SUBTRACTION
    | (MaybeNegativeEpsilon) /* epsilon */;

/*
Statement = DesignatorStatement ";"
| "if" "(" Condition ")" Statement ["else" Statement]
| "while" "(" Condition ")" Statement
| "break" ";"
| "continue" ";"
| "return" [Expr] ";"
| "read" "(" Designator ")" ";"
| "print" "(" Expr ["," numConst] ")" ";"
| Designator "." "foreach" "(" ident "=>" Statement ")" ";" * za B i C nivo
| "{" {Statement} "}"
*/

MaybeExpr ::=
    (MaybeExprIsExpr) Expr
    | (MaybeExprEpsilon) /* epsilon */;

//Statement ::=
//    (StatementMatchedStatement) MatchedStatement
//    | (StatementUnmatchedStatement) UnmatchedStatement;

//UnmatchedStatement ::=
//    (UnmatchedStatementIF) IF LEFT_PARENTHESES Condition RIGHT_PARENTHESES Statement
//    | (UnmatchedStatementELSE) IF Condition MatchedStatement ELSE UnmatchedStatement;

/* TODO(acko): ForEach */

Statement ::=
//MatchedStatement ::=
    (MatchedIF) IF LEFT_PARENTHESES Condition RIGHT_PARENTHESES Statement
    | (MatchedElse)  IF Condition Statement ELSE Statement
    | (MatchedStatementDesignatorStatement) DesignatorStatement SEMI_COLON
    | (MatchedStatementWhile) WHILE LEFT_PARENTHESES Condition RIGHT_PARENTHESES Statement
    | (MatchedStatementBreak) BREAK SEMI_COLON
    | (MatchedStatementContinue) CONTINUE SEMI_COLON
    | (MatchedStatementReturn) RETURN MaybeExpr SEMI_COLON
    | (MatchedStatementRead) READ LEFT_PARENTHESES Designator RIGHT_PARENTHESES SEMI_COLON
    | (MatchedStatementPrint) PRINT LEFT_PARENTHESES Expr MaybePrintNumConst RIGHT_PARENTHESES SEMI_COLON
    | (MatchedStatementForEach) FOR_EACH SEMI_COLON
    | (MatchedStatementStatementList) LEFT_BRACE StatementList RIGHT_BRACE;


StatementList ::=
    (Statements) StatementList Statement
    | (StatementListEpsilon) /* epsilon */;

MaybePrintNumConst ::=
    (MaybePrintNumCostIsPrintNumCost) COMMA CONST_NUMBER
    | (MaybePrintNumCostEpsilon) /* epsilon */;

/* TODO (acko): Need to follow up on requirements for B and C */
/* TODO (acko): Need to handle Designator ([ActPars]) */

/* DesignatorStatement := "[" [Designator] {"," [Designator]}"]" "=" Designator */

// [a, b, c] = niz
DesignatorStatement ::=
    (DesignatorStatementAssignment) Designator AssignmentOperator Expr
    | (DesignatorStatementUnpack) LEFT_BRACKET DesignatorList RIGHT_BRACKET AssignmentOperator Designator
    | (DesignatorStatementIncrement) Designator INCREMENT
    | (DesignatorStatementDecrement) Designator DECREMENT;

MaybeDesignator ::=
    (MaybeDesignatorIsDesignator) Designator
    | (MaybeDesignatorEpsilon) /* epsilon */;

DesignatorList ::=
    (DeisgnatorListMulti) DesignatorList COMMA MaybeDesignator
    | (DesignatorListSingle) MaybeDesignator;

MaybeActPars ::=
    (MaybeActParsIsActPars) ActPars
    | (MaybeActParsEpsilon) /* epsilon */;

ActPars ::=
    (ActParsList) ActPars COMMA Expr
    | (ActParsSingleExpr) Expr;

MaybeActParsInvocation ::=
    (MaybeActParsInvocationIsInvocation) LEFT_PARENTHESES MaybeActPars RIGHT_PARENTHESES
    | (MaybeActParsInvocationEpsilon) /* epsilon */;

/* Designator := ident [ "[" Expr "]" ] */
/* TODO (acko): This is not correct... */

Designator ::=
    (DesignatorIdentifier) IDENTIFIER DesigSuffix;

DesigSuffix ::=
    DesigSuffix SingleDesignator
    | /* epsilon */;

SingleDesignator ::=
    DOT IDENTIFIER
    | LEFT_BRACKET Expr RIGHT_BRACKET;

//MaybeSubscript ::=
//    (MaybeSubscriptIsSubscript) LEFT_BRACKET Expr RIGHT_BRACKET
//    | (MaybeSubscriptEpsilon) /* epsilon */;

/* Condition = CondTerm {"||" CondTerm} */

Condition ::=
    (CondtitionOR) Condition OR CondTerm
    | (ConditionSingleCondTerm) CondTerm;

/* CondTerm = CondFact {"&&" CondFact} */

CondTerm ::=
    (CondTermAND) CondTerm AND CondFact
    | (CondTermSingleCondFact) CondFact;

/* CondFact = Expr [Relop Expr] */

CondFact ::=
    (CondFactRelOp) Expr RelationOperator Expr;

/* Expr = ["‐"] Term {Addop Term} */

// 		bodovi = -bodovi + (pet * a / 2 - jedan) * bodovi - (3 % 2 + 3 * 2 - 3);

Expr ::=
    (ExprList) Expr AdditionOperator Term
    | (ExprSingleTerm) MaybeNegative Term;

/* Term := Factor {Mulop Factor} */

Term ::=
    (TermList) Term MultiplicationOperator Factor
    | (TermFactor) Factor;

/* TODO (acko): This needs to be upgraded to handle Expr and new and designator */

/* Factor := numConst | charConst | "(" Expr ")" | boolConst | "new" Type "[" Expr "]"| Designator */

/*
    Factor = Designator ["(" [ActPars] ")"]
    | numConst
    | charConst
    | boolConst
    | "new" Type ( "[" Expr "]" | "" ([ActPars] ")" )
    | "(" Expr ")".

    TODO (acko): Do we need this optional ActPars?
*/

Factor ::=
    (FactorDesignator) Designator // MaybeActParsInvocation
    | (FactorConstant) Constant
    | (FactorNew) NEW Type LEFT_BRACKET Expr RIGHT_BRACKET;
   // | (FactorExpr) LEFT_PARENTHESES Expr RIGHT_PARENTHESES;
    // TODO (acko) Why is this a conflict? | (FactorExpr) LEFT_PARENTHESES Expr RIGHT_PARENTHESES;

/* Assignop = "=" */

AssignmentOperator ::=
    (AssignmentOperator) ASSIGNMENT;

/* Relop = "==" | "!=" | ">" | ">=" | "<" | "<=" */

RelationOperator ::=
    (RelationOperatorquals) EQUALS
    | (RelationOperatorNotEquals) NOT_EQUALS
    | (RelationOperatorGreaterThan) GREATER_THAN
    | (RelationOperatorGreaterOrEqualThan) GREATER_OR_EQUAL_THAN
    | (RelationOperatorLessThan) LESS_THAN
    | (RelationOperatorLessOrEqualThan) LESS_OR_EQUAL_THAN;

/* Addop = "+" | "‐" */

AdditionOperator ::=
    (AdditionOperatorAddition) ADDITION
    | (AdditionOperatorSubtraction) SUBTRACTION;

/* Mulop = "*" | "/" | "%" */

MultiplicationOperator ::=
    (MultiplicationOperatorMultiplication) MULTIPLICATION
    | (MultiplicationOperatorDivision) DIVISION
    | (MultiplicationOperatorModulo) MODULO;
