package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.util.*;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

parser code {:
    Logger logger = LogManager.getLogger(MJParser.class);

    boolean errorDetected = false;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol curr_token) {
        report_error("Syntax error while parsing", curr_token);
    }

    public void unrecovered_syntax_error(Symbol curr_token) throws java.lang.Exception {
        report_fatal_error("Could not recover from syntax error", curr_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            msg.append(" on line ").append(symbol.left);
            msg.append(" and column ").append(symbol.right);
            msg.append(" while parsing ").append(LexerUtils.GetLexicalIdentifier(symbol.toString()));
            msg.append(" with value ").append(symbol.value);
        }
        logger.error(msg.toString());

        errorDetected = true;
    }
:}

scan with {:
    Symbol symbol = this.getScanner().next_token();
    if (symbol != null && symbol.value != null) {
        logger.info("Line " + symbol.left + ": " + "Parsed symbol: " + symbol.value + " - " + LexerUtils.GetLexicalIdentifier(symbol.toString()));
    }
    return symbol;
:}

//nonterminal Program, ProgramName;

terminal String IDENTIFIER;
terminal Integer CONST_NUMBER;
terminal Character CONST_CHARACTER;

/*
    Keywords:
        program, break, class, enum, else, const, if, do, while, new, print, read,
        return, void, extends, continue, this, foreach
*/
terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ;
terminal EXTENDS, CONTINUE, FOR_EACH;
terminal THEN, STATIC;

/* TODO (acko): enum, do, this, return, void, this, THEN??? STATIC??? */

terminal RETURN;

/* Constants */
terminal CONST_BOOLEAN;

/* Operators */
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal INCREMENT, DECREMENT;
terminal AND, OR;
terminal LAMBDA;
terminal LEFT_PARENTHESES, RIGHT_PARENTHESES, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal DOT, COMMA, SEMI_COLON;
terminal ASSIGNMENT;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_OR_EQUAL_THAN, LESS_OR_EQUAL_THAN;

//nonterminal GlobalDeclarationList, GlobalDeclarataion;
//nonterminal ConstantDeclarationList, VariableDeclarationList, ClassDeclarationList, MethodDeclarationList;
//nonterminal AssignmentOperator, RelationOperator, AdditionOperator, MultiplicationOperator;

//nonterminal Type, MethodDeclaration, MethodTypeName, FormalParameters;

/* ========================================================================== */


/* Program */
nonterminal Program Program;
nonterminal GlobalDeclarationList GlobalDeclarationList;
nonterminal GlobalDeclaration GlobalDeclaration;
nonterminal MethodDeclarationList MethodDeclarationList;
nonterminal MethodDeclaration MethodDeclaration;

/* Common */
nonterminal Type Type;
nonterminal Sign Sign;
nonterminal MaybeArray MaybeArray;

/* Constants */
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclarationList ConstDeclarationList;
nonterminal ConstAssignment ConstAssignment;
nonterminal Constant Constant;

/* Variables */
nonterminal VarDecl VarDecl;
nonterminal VariableDeclarationList VariableDeclarationList;
nonterminal VariableDeclaration VariableDeclaration;

/* Operators */
nonterminal AssignmentOperator AssignmentOperator;
nonterminal AdditionOperator AdditionOperator;
nonterminal MultiplicationOperator MultiplicationOperator;
nonterminal RelationalOperator RelationalOperator;

/* TODO (acko): Rewrite this */
nonterminal Statement Statement;
nonterminal Expr Expr;
nonterminal Factor Factor;
nonterminal Term Term;
nonterminal Designator Designator;
nonterminal ConstFactor ConstFactor;

/*
    Program = "program" ident {ConstDecl | VarDecl | ClassDecl} "{" {MethodDecl} "}".

    Introduce a new nonterminal GlobalDeclaration = ConstDecl | VarDecl | ClassDecl
*/

Program ::=
    (Program) PROGRAM IDENTIFIER:I1 SEMI_COLON GlobalDeclarationList:G2 LEFT_BRACE MethodDeclarationList:M3 RIGHT_BRACE {: RESULT=new Program(I1, G2, M3); RESULT.setLine(I1left); :};

GlobalDeclarationList ::=
    (GlobalDeclarationListMulti) GlobalDeclarationList:G1 GlobalDeclaration:G2 {: RESULT=new GlobalDeclarationListMulti(G1, G2); RESULT.setLine(G1left); :}
    | (GlobalDeclarationListEpsilon) {: RESULT=new GlobalDeclarationListEpsilon(); :} /* epsilon */;

GlobalDeclaration ::=
    (GlobalDeclarationConstDecl) ConstDecl:C1 {: RESULT=new GlobalDeclarationConstDecl(C1); RESULT.setLine(C1left); :}
    | (GlobalDeclarationVarDecl) VarDecl:V1 {: RESULT=new GlobalDeclarationVarDecl(V1); RESULT.setLine(V1left); :};

/* ConstDecl = "const" Type ident"="(numConst | charConst | boolConst) {, ident "=" (numConst | charConst | boolConst)} ";" */

ConstDecl ::=
    (ConstDecl) CONST Type:T1 ConstDeclarationList:C2 SEMI_COLON {: RESULT=new ConstDecl(T1, C2); RESULT.setLine(T1left); :};

ConstDeclarationList ::=
    (ConstDeclarationListMulti) ConstDeclarationList:C1 COMMA ConstAssignment:C2 {: RESULT=new ConstDeclarationListMulti(C1, C2); RESULT.setLine(C1left); :}
    | (ConstDeclarationListSingle) ConstAssignment:C1 {: RESULT=new ConstDeclarationListSingle(C1); RESULT.setLine(C1left); :};

ConstAssignment ::=
    (ConstAssignment) IDENTIFIER:I1 AssignmentOperator:A2 Constant:C3 {: RESULT=new ConstAssignment(I1, A2, C3); RESULT.setLine(I1left); :};

Constant ::=
    (ConstantNumber) Sign:S1 CONST_NUMBER:C2 {: RESULT=new ConstantNumber(S1, C2); RESULT.setLine(S1left); :}
    | (ConstantCharacter) CONST_CHARACTER:C1 {: RESULT=new ConstantCharacter(C1); RESULT.setLine(C1left); :}
    | (ConstantBoolean) CONST_BOOLEAN {: RESULT=new ConstantBoolean(); :};

/* VarDecl = Type ident ["[" "]"] {"," ident ["[" "]"]} ";" */

VarDecl ::=
    Type:T1 VariableDeclarationList:V2 SEMI_COLON {: RESULT=new VarDeclDerived1(T1, V2); RESULT.setLine(T1left); :};

VariableDeclarationList ::=
    (VariableDeclarationListMulti) VariableDeclarationList:V1 COMMA VariableDeclaration:V2 {: RESULT=new VariableDeclarationListMulti(V1, V2); RESULT.setLine(V1left); :}
    | (VariableDeclarationSingle) VariableDeclaration:V1 {: RESULT=new VariableDeclarationSingle(V1); RESULT.setLine(V1left); :};

VariableDeclaration ::=
    (VariableDeclaration) IDENTIFIER:I1 MaybeArray:M2 {: RESULT=new VariableDeclaration(I1, M2); RESULT.setLine(I1left); :};

MethodDeclarationList ::=
    (MethodDeclarationListMulti) MethodDeclarationList:M1 MethodDeclaration:M2 {: RESULT=new MethodDeclarationListMulti(M1, M2); RESULT.setLine(M1left); :}
    | (MethodDeclarationListEpsilon) {: RESULT=new MethodDeclarationListEpsilon(); :} /* epsilon */;

MethodDeclaration ::= Statement:S1 {: RESULT=new MethodDeclarationDerived1(S1); RESULT.setLine(S1left); :};

/*
    ClassDecl = "class" ident ["extends" Type] "{" {VarDecl} ["{" {ConstructorDecl} {MethodDecl} "}"] "}"
    ConstructorDecl = ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}. * za C nivo'

    TODO (acko): Add ClassDecl/ConstructorDecl
*/

/* Factor := numConst | charConst | "(" Expr ")" | boolConst | "new" Type "[" Expr "]"| Designator */

/*
    Factor = Designator ["(" [ActPars] ")"]
    | numConst
    | charConst
    | boolConst
    | "new" Type ( "[" Expr "]" | "" ([ActPars] ")" )
    | "(" Expr ")".
*/

/* TODO (acko): Rewrite this */
Statement ::=
    (StatementPrint) PRINT LEFT_PARENTHESES Expr:E1 RIGHT_PARENTHESES SEMI_COLON {: RESULT=new StatementPrint(E1); RESULT.setLine(E1left); :};

Expr ::=
    (ExprMulti) Expr:E1 AdditionOperator:A2 Term:T3 {: RESULT=new ExprMulti(E1, A2, T3); RESULT.setLine(E1left); :}
    | (ExprSingle) Sign:S1 Term:T2 {: RESULT=new ExprSingle(S1, T2); RESULT.setLine(S1left); :};

Term ::=
    (TermMulti) Term:T1 MultiplicationOperator:M2 Factor:F3 {: RESULT=new TermMulti(T1, M2, F3); RESULT.setLine(T1left); :}
    | (TermSingle) Factor:F1 {: RESULT=new TermSingle(F1); RESULT.setLine(F1left); :};

Factor ::=
    (FactorConstant) ConstFactor:C1 {: RESULT=new FactorConstant(C1); RESULT.setLine(C1left); :}
    | (FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
    | (FactorExpr) LEFT_PARENTHESES Expr:E1 RIGHT_PARENTHESES {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :};

ConstFactor ::=
    CONST_NUMBER:C1 {: RESULT=new ConstFactorDerived1(C1); RESULT.setLine(C1left); :}
    | CONST_CHARACTER:C1 {: RESULT=new ConstFactorDerived2(C1); RESULT.setLine(C1left); :}
    | CONST_BOOLEAN {: RESULT=new ConstFactorDerived3(); :};

Designator ::=
    (DesignatorIdentifier) IDENTIFIER:I1 {: RESULT=new DesignatorIdentifier(I1); RESULT.setLine(I1left); :};

/* Assignop = "=" */

AssignmentOperator ::=
    (AssignmentOperator) ASSIGNMENT {: RESULT=new AssignmentOperator(); :};

/* AddOp = "+" | "â€?" */

AdditionOperator ::=
    (AdditionOperatorAddition) ADDITION {: RESULT=new AdditionOperatorAddition(); :}
    | (AdditionOperatorSubtraction) SUBTRACTION {: RESULT=new AdditionOperatorSubtraction(); :};

/* MulOp = "*" | "/" | "%" */

MultiplicationOperator ::=
    (MultiplicationOperatorMultiplication) MULTIPLICATION {: RESULT=new MultiplicationOperatorMultiplication(); :}
    | (MultiplicationOperatorDivision) DIVISION {: RESULT=new MultiplicationOperatorDivision(); :}
    | (MultiplicationOperatorModulo) MODULO {: RESULT=new MultiplicationOperatorModulo(); :};

/* RelOp = "==" | "!=" | ">" | ">=" | "<" | "<=" */

RelationalOperator ::=
    (RelationalOperatorEquals) EQUALS {: RESULT=new RelationalOperatorEquals(); :}
    | (RelationalOperatorNotEquals) NOT_EQUALS {: RESULT=new RelationalOperatorNotEquals(); :}
    | (RelationalOperatorGreaterThan) GREATER_THAN {: RESULT=new RelationalOperatorGreaterThan(); :}
    | (RelationalOperatorGreaterOrEqualThan) GREATER_OR_EQUAL_THAN {: RESULT=new RelationalOperatorGreaterOrEqualThan(); :}
    | (RelationalOperatorLessThan) LESS_THAN {: RESULT=new RelationalOperatorLessThan(); :}
    | (RelationalOperatorLessOrEqualThan) LESS_OR_EQUAL_THAN {: RESULT=new RelationalOperatorLessOrEqualThan(); :};

/* Type = ident */

Type ::=
    (Type) IDENTIFIER:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};

/* Sign = [ "+" | "-" ] */
Sign ::=
    (SignPositive) ADDITION {: RESULT=new SignPositive(); :}
    | (SignNegative) SUBTRACTION {: RESULT=new SignNegative(); :}
    | (SignEpsilon) {: RESULT=new SignEpsilon(); :} /* epsilon */;

/* MaybeArray = [ "[" "]" ] */

MaybeArray ::=
    (MaybeArrayIsArray) LEFT_BRACKET RIGHT_BRACKET {: RESULT=new MaybeArrayIsArray(); :}
    | (MaybeArrayEpsilon) {: RESULT=new MaybeArrayEpsilon(); :} /* epsilon */;

